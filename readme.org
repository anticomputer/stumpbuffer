* StumpBuffer

  An IBuffer inspired tool to control Stumpwm from Emacs. Still
  experimental and unstable. Currently does not work with float
  groups.

  Uses a lot of Stumpwms internals. This can't really be avoided since
  Stumpwm doesn't expose everything for programmatic access. Using the
  built-in commands would generally not work as those tend to require
  the target to be focused, while StumpBuffer must be able to execute
  them remotely.

* Installing

  Ensure that you have stumpish available. Load ~emacs/stumpbuffer/~
  in Emacs and ~cl/stumpbuffer/~ in Stumpwm.

* Use

  Use ~M-x stumpbuffer~ to open the buffer. This should show all
  groups and windows. ~M-x stumpbuffer-other-frame~ can be used to
  open the buffer in another frame, which will be killed when exiting
  the stumpbuffer.

  | Key       | Command                                                                                 |
  |-----------+-----------------------------------------------------------------------------------------|
  | ~n~       | Move to next line                                                                       |
  | ~p~       | Move to previous line                                                                   |
  | ~C-n~     | Move to next frame                                                                      |
  | ~C-p~     | Move to previous frame                                                                  |
  | ~TAB~     | Move to next group                                                                      |
  | ~BACKTAB~ | Move to previous group                                                                  |
  | ~g~       | Update                                                                                  |
  | ~RET~     | Focus and switch to                                                                     |
  | ~m~       | Mark                                                                                    |
  | ~u~       | Unmark                                                                                  |
  | ~U~       | Unmark all                                                                              |
  | ~% r~     | Mark windows whose title matches a regex                                                |
  | ~% R~     | Mark windows by role (defaults to current windows role, use prefix arg to force prompt) |
  | ~% c~     | Mark windows by class (same)                                                            |
  | ~% i~     | Mark windows by instance (same)                                                         |
  | ~% f~     | Mark windows in the same frame as the current window                                    |
  | ~% g~     | Mark windows in the same group as the current window                                    |
  | ~d~       | Mark for deletion (asks window to close itself)                                         |
  | ~k~       | Mark for kill (forces window to die; you should usually use delete instead)             |
  | ~*~       | Change all ~*~ marks to a different character                                           |
  | ~x~       | Execute marks                                                                           |
  | ~D~       | Delete                                                                                  |
  | ~K~       | Kill window (force it to die)                                                           |
  | ~N~       | Rename                                                                                  |
  | ~P~       | Pull (move marked windows here)                                                         |
  | ~T~       | Throw (move marked windows there)                                                       |
  | ~q~       | Quit                                                                                    |
  | ~s~       | Split frame vertically (only when point on frame name or window)                        |
  | ~S~       | Split frame horizontally (only when point on frame name or window)                      |
  | ~C~       | Create new group (takes marked windows with it)                                         |
  | ~f~       | Toggle frame name display                                                               |
  | ~r~       | Renumber group or window                                                                |
  | ~`~       | Cycle filter groups                                                                     |
  | ~^~       | Select filter group by name                                                             |
  | ~/ h~     | Push a quick filter to hide hidden groups                                               |
  | ~/ H~     | Push a quick filter to only show hidden groups                                          |
  | ~/ r~     | Push a quick filter to only show windows with a title matching a regex                  |
  | ~/ c~     | Push a quick filter to only show windows with a specific class                          |
  | ~/ R~     | Push a quick filter to only show windows with a specific role                           |
  | ~/ i~     | Push a quick filter to only show windows with a specific instance                       |
  | ~\~       | Pop the quick filter stack. Positive numeric argument pops multiple, negative pops all. |
  
  The customization option ~stumpbuffer-quit-window-after-command~
  determines whether the buffer should be killed when executing
  certain commands (such as focusing a
  window). ~stumpbuffer-show-frames-p~ can be set to ~nil~ to hide
  frames from the list.

** Window row format
  
  The variable ~stumpbuffer-window-format~ determines which fields to
  show for windows. It should be a list of three element lists in form

  #+BEGIN_EXAMPLE
  ((field-key &optional width title format-fn)
   ...)
  #+END_EXAMPLE

  The ~field-key~ is the key returned by Stumpwm. ~width~ is the
  number of characters to show. The last field can have width of
  ~nil~. ~title~ is the title to show in the header. ~format-fn~ can
  be a custom function to format the fields value. The function takes
  a single argument -- the value -- and returns a string that should
  be shown in its place.

** Frame and group name format
  
  The variables ~stumpbuffer-frame-name-format~ and
  ~stumpbuffer-group-name-format~ control the format of frame and
  group names. They should be lists of lists in form

  #+BEGIN_EXAMPLE
  ((faces . things)
   ...)
  #+END_EXAMPLE

  Where ~faces~ is the name of a face or a list of face
  names. ~things~ is a list of things to insert. They can be

  - Strings :: Inserted as they are.
  - Keywords :: The key is looked up in the frame or group plist
                retrieved from Stumpwm.
  - A list ~(:call fn)~ :: Call ~fn~ with the plist. If it returns
       ~nil~, insert nothing. Otherwise insert the result.

** Faces

   Window names can be highlighted with custom faces. The variable
   ~stumpbuffer-window-faces~ is an alist of ~(fn . face)~ pairs. The
   ~face~ will be used for windows where ~fn~ return true.

   For example, the default value

   #+BEGIN_EXAMPLE
     '((stumpbuffer-window-visible-p . bold)
       (stumpbuffer-window-hidden-p . shadow))
   #+END_EXAMPLE

   will highlight all visible windows with the ~bold~ face, and hidden
   windows (iconified windows) with ~shadow~. If you wanted to
   highlight all Emacs windows with ~font-lock-string-face~, you could
   put

   #+BEGIN_EXAMPLE
     (defun my-stumpbuffer-emacs-p (window)
       (string-equal (getf window :class) "Emacs"))

     (add-to-list 'stumpbuffer-window-faces
                  '(my-stumpbuffer-emacs-p . font-lock-string-face))
   #+END_EXAMPLE

   in you Emacs init-file. Notice that all matching faces will be
   added to the windows, in the order they appear in. So in this case
   visible Emacs windows will have both ~bold~ and
   ~font-lock-string-face~.
   
** Filters

   The variable ~stumpbuffer-filter-groups~ contains an alist of
   filter groups. Each group should be a cons cell of a name (a
   string) and a list of filters in form ~(what . how)~. ~what~ should
   be either ~:hide-groups~, ~:show-groups~, ~:hide-windows~ or
   ~:show-windows~. The ~:hide-~ variants hide matching windows or
   groups, while the ~:show-~ variants hide non-matching ones.

   ~how~ is the actual filter. The currently implemented filters are:

   - ~(:satisfying fn)~ :: Matches if calling ~fn~ on the group or
        window plist returns true.
   - ~(:where field :matches regex)~ :: Matches if ~field~ in the
        group or window plist matches the regular expression ~regex~.
   - ~(:where field :is value)~ :: Matches if ~field~ in the group or
        window plist is ~equal~ to ~value~.

   For example (the default value),

   #+BEGIN_EXAMPLE
     '(("Everything")
       ("No hidden groups"
        (:hide-groups :satisfying stumpbuffer-group-hidden-p))
       ("Only hidden groups"
        (:show-groups :satisfying stumpbuffer-group-hidden-p)))
   #+END_EXAMPLE

   This defines three filter groups. The first one (the default group)
   will show everything. The second one hides all hidden groups. The
   third one only shows hidden groups. ~stumpbuffer-group-hidden-p~ is
   a very simple function:

   #+BEGIN_EXAMPLE
     (defun stumpbuffer-group-hidden-p (group)
       (getf group :hiddenp))
   #+END_EXAMPLE

   Stumpwm provides ~:hiddenp~ in group plists to tell whether it is a
   hidden group.
  
** Quick filters

   Quick filters are filters that are pushed onto a buffer local
   stack. Their syntax is the same as predefined filters. They can be
   pushed to the stack with key bindings starting with ~/~ and popped
   with ~\~.

   For example, to quickly filter down to windows whose title contains
   the word "emacs", use ~/ r emacs RET~. Using ~\~ will remove the
   filter.
   
* Extending

** Stumpwm

   Variables ~STUMPBUFFER:*WINDOW-DATA-FIELDS*~,
   ~STUMPBUFFER:*GROUP-DATA-FIELDS*~ and
   ~STUMPBUFFER:*FRAME-DATA-FIELDS*~ contain alists of custom data
   fields to be passed to Emacs. The keys should be keywords and
   values functions to generate the value. For windows and groups the
   function takes a single argument, while frame functions should take
   both the group and the frame (in that order).

   The values should be something that can be printed out, and read by
   emacs. In other words, stick with keywords, numbers and strings.

** Emacs
*** Key maps

    ~stumpbuffer-mode-map~ is for keys that are always active in the
    buffer. ~stumpbuffer-mode-group-map~, ~stumpbuffer-mode-frame-map~
    and ~stumpbuffer-mode-window-map~ are only active when point is on
    a group name, frame name or a window respectively.
   
*** Marking

    ~stumpbuffer-mark~ and ~stumpbuffer-unmark~ can be used to add or
    remove mark from the window at point.

    ~stumpbuffer-mark-group~ and ~stumpbuffer-mark-frame~ will add a
    mark to all windows in the group or frame. They have a
    corresponding unmark function.

    When adding multiple marks, it's better to use
    ~stumpbuffer-change-window-mark~. It doesn't have any other
    side-effects.
    
*** Getting information about things at point

    ~stumpbuffer-on-group-name~, ~stumpbuffer-on-frame-name~ and
    ~stumpbuffer-on-window~ will return a plist with information about
    the thing at point.

    Each of the plists have keys ~:start~ and ~:end~ containing the
    character positions of the thing. There is also a key
    ~<group|frame|window>-plist~ containing the property list
    retrieved from Stumpwm. Windows and frames also have the key
    ~:group~ containing the number of the group they're in. Windows
    may have a key ~:mark~ with the current mark of the window.

*** Custom mark functions

    The variable ~stumpbuffer-mark-functions~ contains an alist of
    mark characters and functions to call during
    ~stumpbuffer-execute-marks~. The function should take the window
    plist as returned by ~stumpbuffer-on-window~.
    
*** Iterating groups and windows

    ~stumpbuffer-map-groups~ can be used to apply a function to each
    group. The function should take a single argument, the plist
    returned by ~stumpbuffer-on-group-name~. The function will be
    called with point on the group name. Results of the function are
    discarded.

    ~stumpbuffer-map-windows~ calls a function on all
    windows. ~stumpbuffer-map-group-windows~ calls a function on
    windows in the group the point is
    on. ~stumpbuffer-map-marked-windows~ calls a function on marked
    windows.

    All of these have a corresponding macro
    ~stumpbuffer-do-<something>~.
   
*** Filters

    The filter syntax can be extended by adding a function to the list
    ~stumpbuffer-filter-handlers~. The function should take two
    arguments:

    1. A filter query (such as ~(:where foo :is bar)~).
    2. A group or window plist as retrieved from Stumpwm.

    The function should return true if the group or window should be
    filtered. For example, the ~(:where _ :is _)~ filter is defined as

    #+BEGIN_EXAMPLE
      (defun sb--where-is-filter-handler (how plist)
        (pcase how
          (`(:where ,field :is ,value)
           (equal value (cl-getf plist field)))))

      (add-to-list 'stumpbuffer-filter-handlers
                   'sb--where-is-filter-handler)
    #+END_EXAMPLE

*** Communicating with Stumpwm

    Communication happens through stumpish. ~stumpbuffer-command~ can
    be used to execute a command. The name will automatically have
    ~stumpbuffer-~ prepended to it, so the commands on Stumpwm side
    should have that prefix (alternatively just call stumpish
    yourself).

    The command should return something that Emacs can ~read~. This
    will be returned from ~stumpbuffer-command~. 

    There is a simple error handling mechanism. The command can return
    a two element list ~(:error msg)~, in which case Emacs will
    ~error~ with the message.
    
    Notice that since the communication goes through stumpish, the CL
    code must use ~MESSAGE~ to return values.
* Example

  Let's say we want to add some kind of a window tagging
  feature. We'll use an org-mode like syntax for tags:
  ~:foo:bar:quux:~. The tags can be used to mark windows with a tag
  query. The query syntax is also org-mode:ish:

  - ~foo~ :: Match windows with a foo tag.
  - ~+foo -bar~ :: Match windows with a ~foo~ tag, but no ~bar~ tag.
  - ~foo-bar+quux~ :: Match ~foo~ and ~quux~ and no ~bar~.

  First, we need to store the tags somehow in Stumpwm. Let's just use
  a simple weak hash table (with SBCL).

  #+BEGIN_EXAMPLE
    (defvar *window-tags* (make-hash-table :weakness :key))

    (defun window-tags (window)
      (gethash window *window-tags* ":")) ;Use : for empty taglist

    (defun (setf window-tags) (new-value window)
      (setf (gethash window *window-tags*) new-value))
  #+END_EXAMPLE

  Then we must add the tags to the custom data fields for windows.

  #+BEGIN_EXAMPLE
    (pushnew (cons :tags 'window-tags) stumpbuffer:*window-data-fields*
             :test #'equal)
  #+END_EXAMPLE

  And make a command to set new tags. This has a slight problem of not
  accepting an empty string through Stumpish. We work around that in
  Emacs by adding a ~:~ instead of empty tag list.
  
  #+BEGIN_EXAMPLE
    (defcommand stumpbuffer-set-window-tags (window-id new-tags)
        ((:number "Window- ID")
         (:string "Tags: "))
      (stumpbuffer:with-simple-error-handling
        (let ((window (stumpbuffer:find-window-by-id window-id)))
          (setf (window-tags window) (or new-tags "")))))
  #+END_EXAMPLE

  That's all we need on the Stumpwm side, because we're not really
  interested in doing anything with the tags in Stumpwm itself. For
  Emacs we have to write a bit more code to manage the tags with.

  First, make the tag field visible.

  #+BEGIN_EXAMPLE
    (setq stumpbuffer-window-format
          '((:number 3 "N")
            (:title 35 "Title")
            (:class 10 "Class")
            (:role 10 "Role")
            (:instance 10 "Instance")
            (:tags nil "Tags")))
  #+END_EXAMPLE

  Then add a simple command to edit tags. We'll also bind it to ~t~
  for window rows only using the ~stumpbuffer-mode-window-map~.

  #+BEGIN_EXAMPLE
    (defun my-stumpbuffer-set-window-tags (window-id new-tags &optional updatep)
      (interactive (let ((wplist (cl-getf (stumpbuffer-on-window) :window-plist)))
                     (list (cl-getf wplist :id)
                           (read-string "Tags: " (cl-getf wplist :tags))
                           t)))
      (when (and window-id new-tags)
        (stumpbuffer-command "set-window-tags" window-id new-tags)
        (when updatep
          (stumpbuffer-update))))

    (define-key stumpbuffer-mode-window-map (kbd "t")
      'my-stumpbuffer-set-window-tags)
  #+END_EXAMPLE

  For queries we'll have to write some code to parse the tags and the
  query strings and match them.

  #+BEGIN_EXAMPLE
    (defun my-stumpbuffer-parse-query (query)
      (cl-loop with start-pos = 0
               for match-pos = (string-match
                                "\\(\\(?: \\|^\\|\\+\\|-\\)[^ +-]+\\)"
                                query start-pos)
               while match-pos
               collect (let ((match (string-trim (match-string 1 query))))
                         (cl-case (aref match 0)
                           (?+ (cons :positive (subseq match 1)))
                           (?- (cons :negative (subseq match 1)))
                           (otherwise (cons :positive match))))
               do (setq start-pos (1+ match-pos))))

    (defun my-stumpbuffer-parse-tags (tags)
      (cl-loop with start-pos = 0
               for match-pos = (string-match ":\\([^:]+\\)" tags start-pos)
               while match-pos
               collect (match-string 1 tags)
               do (setq start-pos (1+ match-pos))))

    (defun my-stumpbuffer-match-tags (tags parsed-query)
      (let ((parsed-tags (my-stumpbuffer-parse-tags tags)))
        (cl-every (lambda (query-part)
                    (cl-destructuring-bind (type . tag) query-part
                      (cl-case type
                        (:positive (member tag parsed-tags))
                        (:negative (not (member tag parsed-tags))))))
                  parsed-query)))
  #+END_EXAMPLE

  With these it's easy to write a command to mark windows by a tag
  query. We'll bind it to ~% t~ in the whole buffer.

  #+BEGIN_EXAMPLE
    (defun my-stumpbuffer-mark-windows-by-tag-query (query mark)
      (interactive (list (read-string "Query: ")
                         (if current-prefix-arg
                             (read-char "Mark: ")
                           ?*)))
      (let ((parsed-query (my-stumpbuffer-parse-query query)))
        (stumpbuffer-do-windows (win)
          (let ((tags (cl-getf (cl-getf win :window-plist) :tags)))
            (when (my-stumpbuffer-match-tags tags parsed-query)
              (stumpbuffer-mark mark))))))

    (define-key stumpbuffer-mode-map (kbd "% t")
      'my-stumpbuffer-mark-windows-by-tag-query)
  #+END_EXAMPLE

  Let's also write commands to add or remove a single tag from marked
  windows (or the highlighted one). Those will be bound to ~+~ and ~-~
  respectively.

  #+BEGIN_EXAMPLE
    (defun my-stumpbuffer-concat-tags (tags)
      (with-output-to-string
        (write-char ?:)
        (cl-loop for tag in (cl-remove-duplicates tags :test #'string-equal)
                 do (princ tag)
                 (write-char ?:))))

    (defun my-stumpbuffer-add-tag (tag)
      (interactive (list (string-trim (read-string "Tag: "))))
      (cl-flet ((try-add-tag (win)
                             (let* ((wplist (cl-getf win :window-plist))
                                    (tags (my-stumpbuffer-parse-tags
                                           (cl-getf wplist :tags))))
                               (unless (member tag tags)
                                 (my-stumpbuffer-set-window-tags
                                  (cl-getf wplist :id)
                                  (my-stumpbuffer-concat-tags (cons tag tags))
                                  nil)))))
        (let (marksp)
          (stumpbuffer-do-marked-windows (win)
            (let ((mark (cl-getf win :mark)))
              (when (char-equal mark ?*)
                (setq marksp t)
                (try-add-tag win))))
          (unless marksp
            (when-let ((win (stumpbuffer-on-window)))
              (try-add-tag win)))
          (stumpbuffer-update))))

    (defun my-stumpbuffer-remove-tag (tag)
      (interactive (list (string-trim (read-string "Tag: "))))
      (cl-flet ((try-remove-tag (win)
                                (let* ((wplist (cl-getf win :window-plist))
                                       (tags (my-stumpbuffer-parse-tags
                                              (cl-getf wplist :tags))))
                                  (when (member tag tags)
                                    (my-stumpbuffer-set-window-tags
                                     (cl-getf wplist :id)
                                     (my-stumpbuffer-concat-tags (remove tag tags))
                                     nil)))))
        (let (marksp)
          (stumpbuffer-do-marked-windows (win)
            (let ((mark (cl-getf win :mark)))
              (when (char-equal mark ?*)
                (setq marksp t)
                (try-remove-tag win))))
          (unless marksp
            (when-let ((win (stumpbuffer-on-window)))
              (try-remove-tag win)))
          (stumpbuffer-update))))

    (define-key stumpbuffer-mode-map (kbd "+")
      'my-stumpbuffer-add-tag)

    (define-key stumpbuffer-mode-map (kbd "-")
      'my-stumpbuffer-remove-tag)
  #+END_EXAMPLE
  
  Finally we should implement quick filtering based on tag
  queries. This adds filter syntax for ~(:with-tags parsed-query)~ and
  binds ~/ t~ to push such quick filter.

  #+BEGIN_EXAMPLE
    (defun my-stumpbuffer-tag-filter-handler (how plist)
      (pcase how
        (`(:with-tags ,query)
         (when-let ((tags (cl-getf plist :tags)))
           (my-stumpbuffer-match-tags tags query)))))

    (add-to-list 'stumpbuffer-filter-handlers
                 'my-stumpbuffer-tag-filter-handler)

    (defun my-stumpbuffer-push-tag-filter (query)
      (interactive (list (read-string "Query: ")))
      (let ((query (my-stumpbuffer-parse-query query)))
        (stumpbuffer-push-quick-filter
         `(:show-windows :with-tags ,query))
        (stumpbuffer-update)))

    (define-key stumpbuffer-mode-map (kbd "/ t")
      'my-stumpbuffer-push-tag-filter)
  #+END_EXAMPLE
